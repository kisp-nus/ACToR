{"name": "regex_dot_metachar", "description": "Test regex with dot metacharacter", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"abc\\naxc\\na.c\\ntest\" > test_files/dot", "cmd_target": ["cd test_files && ../BINARY dot '/a.c/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 1}
{"name": "regex_missing_trailing", "description": "Test regex missing trailing delimiter", "alias_name": "", "check_file": false, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\\nLine 3\" > test_files/infile", "cmd_target": "cd test_files && ! ../BINARY infile /Line", "cmd_post": "rm -rf test_files", "idx": 2}
{"name": "whitespace_in_regex", "description": "Test regex with whitespace characters", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"no space\\nhas space\\nno\\tspace\\nend\" > test_files/whitespace", "cmd_target": ["cd test_files && ../BINARY whitespace '/has space/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 3}
{"name": "bad_line_number", "description": "Test error handling for bad line number", "alias_name": "", "check_file": false, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\" > test_files/infile", "cmd_target": "cd test_files && ! ../BINARY infile -1", "cmd_post": "rm -rf test_files", "idx": 4}
{"name": "negative_suffix_length", "description": "Test negative suffix length option", "alias_name": "", "check_file": false, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\\nLine 3\" > test_files/infile", "cmd_target": "cd test_files && ! ../BINARY -n -1 infile 2", "cmd_post": "rm -rf test_files", "idx": 5}
{"name": "invalid_repetition", "description": "Test invalid repetition pattern", "alias_name": "", "check_file": false, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\\nLine 3\" > test_files/infile", "cmd_target": "cd test_files && ! ../BINARY infile 2 {abc}", "cmd_post": "rm -rf test_files", "idx": 6}
{"name": "multiline_pattern_match", "description": "Test pattern that could span multiple lines", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"start\\nmiddle\\nend pattern\\nafter\" > test_files/multiline", "cmd_target": ["cd test_files && ../BINARY multiline '/end/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 7}
{"name": "alternation_in_regex", "description": "Test regex with alternation (OR)", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"apple\\nbanana\\ncherry\\ndate\" > test_files/alt", "cmd_target": ["cd test_files && ../BINARY alt '/apple\\|cherry/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 8}
{"name": "regex_with_special_chars", "description": "Test regex with special characters", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"line [1]\\nline (2)\\nline {3}\\nline .4.\" > test_files/special", "cmd_target": ["cd test_files && ../BINARY special '/\\[1\\]/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 9}
{"name": "suffix_overflow", "description": "Test suffix length overflow", "alias_name": "", "check_file": false, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\" > test_files/infile", "cmd_target": "cd test_files && ! ../BINARY -n 20 infile 2", "cmd_post": "rm -rf test_files", "idx": 10}
{"name": "positive_offset_regex", "description": "Test positive offset in regex pattern", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\" > test_files/infile", "cmd_target": ["cd test_files && ../BINARY infile /Line\\ 2/1 > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 11}
{"name": "regex_plus_quantifier", "description": "Test regex with plus quantifier", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"a\\naa\\naaa\\ntest\" > test_files/plus", "cmd_target": ["cd test_files && ../BINARY plus '/a+/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 12}
{"name": "multiple_patterns_line", "description": "Test multiple line number patterns", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\" > test_files/multi", "cmd_target": ["cd test_files && ../BINARY multi 2 4 > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01", "cd test_files && cat xx02"], "cmd_post": "rm -rf test_files", "idx": 13}
{"name": "regex_line_boundary", "description": "Test regex matching at line boundaries", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"start test\\ntest middle\\ntest\\nend\" > test_files/boundary", "cmd_target": ["cd test_files && ../BINARY boundary '/^test$/' > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01"], "cmd_post": "rm -rf test_files", "idx": 14}
{"name": "single_line_file", "description": "Test with single line input file", "alias_name": "", "check_file": true, "cmd_prep": "mkdir -p test_files && printf \"Single line\" > test_files/single", "cmd_target": ["cd test_files && ../BINARY single 1 > /dev/null", "cd test_files && cat xx00", "cd test_files && cat xx01 || echo 'No second file'"], "cmd_post": "rm -rf test_files", "idx": 15}
